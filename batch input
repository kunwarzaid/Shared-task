for t in range(max_turns):
    turns = t + 1
    dr_full = doctor._ask_consensus(sys_p, user_p, debug=True)
    think, dr_text = parse_thinking_and_body(dr_full)

    # âœ… Always capture reasoning at every turn (including test orders)
    if think:
        reasoning_trace += ("\n" + think)

    convo.append({"role": "doctor", "content": dr_text})
    log_trace(f"Doctor: {dr_text}", "DOCTOR")

    # Capture DDx
    ddx = parse_ddx_line(dr_text)
    if ddx:
        ddx_history.append(ddx)

    # Final diagnosis?
    m = re.search(r"DIAGNOSIS READY:\s*(.*)", dr_text, re.I)
    if m:
        diagnosis = m.group(1).strip()
        break

    # Test request branch (must not skip reasoning)
    m2 = re.search(r"REQUEST TEST:\s*(.*)", dr_text, re.I)
    if m2:
        tname = m2.group(1).strip()
        if test_safety:
            ts = test_safety.assess(tname, summary)
            log_trace(f"Test safety: {ts}", "MEASUREMENT")
            convo.append({"role": "system", "content": ts})
        tres = measure.get_result(tname)
        log_trace(f"Test result: {tres}", "MEASUREMENT")
        convo.append({"role": "system", "content": tres})
        user_p = tres
        continue

    # Otherwise, patient responds
    ans = patient.respond(dr_text)
    log_trace(f"Patient: {ans}", "PATIENT")
    convo.append({"role": "patient", "content": ans})
    user_p = ans




    test_safety_notes = [c["content"] for c in convo if c["role"] == "system" and "Risk:" in c["content"]]
    test_safety_str = "\n".join(test_safety_notes)

"test_safety": test_safety_str,
